{"version":3,"sources":["../src/index.js"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/**\n * CSS @scope Polyfill v1.1.1 (Live-Watch Edition)\n * \n * A lightweight runtime polyfill for the CSS @scope at-rule.\n * Now features MutationObserver to handle lazy-loaded and dynamic styles.\n * \n * @author oy3o & Moonlight\n */\n\n/**\n * @param {import(\"./events\").default} [events]\n */\nfunction CSSScopePolyfill(events) {\n    const TAG = '[@scope]';\n    const processedNodes = new WeakSet(); // Memory-safe deduping\n\n    // 1. Feature Detection\n    try {\n        if (typeof CSSScopeRule !== \"undefined\") {\n            console.log(`${TAG} Native support detected. Hibernating.`);\n            return;\n        }\n    } catch (e) { }\n\n    console.log(`${TAG} Activating polyfill (Live Mode)...`);\n\n    /**\n     * Core Logic: Process a specific DOM node (Link or Style)\n     * @param {Element} node\n     */\n    async function processNode(node) {\n        // Circuit Breaker: Skip if already processed\n        if (processedNodes.has(node)) return;\n        processedNodes.add(node);\n\n        // Guard: Skip our own injected polyfill styles to prevent infinite loops\n        if (node.hasAttribute('data-polyfill-generated')) return;\n\n        let cssText = '';\n        let sourceUrl = 'inline-style';\n\n        try {\n            if (node.tagName === 'LINK') {\n                const link = /** @type {HTMLLinkElement} */(node);\n                if (link.rel !== 'stylesheet' || !link.href) return;\n                // Fetch external CSS\n                sourceUrl = link.href;\n                const response = await fetch(sourceUrl);\n                if (!response.ok) return;\n                cssText = await response.text();\n\n            } else if (node.tagName === 'STYLE') {\n                // Read inline CSS\n                cssText = node.textContent;\n            } else {\n                return;\n            }\n\n            // Fast fail: Optimization\n            if (!cssText.includes('@scope')) return;\n\n            const transformedCss = parseAndTransform(cssText);\n            if (transformedCss) {\n                injectStyles(transformedCss, sourceUrl);\n                console.log(`${TAG} Processed ${sourceUrl}`);\n            }\n\n        } catch (e) {\n            console.warn(`${TAG} Failed to process ${sourceUrl}`, e);\n        }\n    }\n\n    /**\n     * Observer: Watches for new nodes entering the DOM\n     */\n    function observeMutations() {\n        if (events) {\n            events.onMutation((mutations) => {\n                for (const node of mutations.added) {\n                    if (node.nodeType === 1) { // ELEMENT_NODE\n                        const el = /** @type {Element} */(node);\n                        // Handle cases where styles are nested inside a container being added\n                        if (isStyleNode(el)) processNode(el);\n                        else el.querySelectorAll?.('link[rel=\"stylesheet\"], style').forEach(processNode);\n                    }\n                }\n            });\n        } else {\n            const observer = new MutationObserver((mutations) => {\n                for (const mutation of mutations) {\n                    if (mutation.type === 'childList') {\n                        mutation.addedNodes.forEach(node => {\n                            if (node.nodeType === 1) { // ELEMENT_NODE\n                                const el = /** @type {Element} */(node);\n                                // Handle cases where styles are nested inside a container being added\n                                if (isStyleNode(el)) processNode(el);\n                                else el.querySelectorAll?.('link[rel=\"stylesheet\"], style').forEach(processNode);\n                            }\n                        });\n                    }\n                }\n            });\n\n            // Watch the entire document body and head\n            observer.observe(document.documentElement, {\n                childList: true,\n                subtree: true\n            });\n        }\n    }\n\n    /**\n     * Helper: Identifies if a node is a target for processing\n     * @param {Element} node\n     * @returns {boolean}\n     */\n    function isStyleNode(node) {\n        // @ts-ignore\n        return (node.tagName === 'LINK' && node.rel === 'stylesheet') || node.tagName === 'STYLE';\n    }\n\n    // --- [Logic Kernel: Unchanged Transformation Logic] ---\n\n    /**\n     * Parse and transform CSS text\n     * @param {string} cssText\n     * @returns {string | null}\n     */\n    function parseAndTransform(cssText) {\n        const cleanCss = cssText.replace(/\\/\\*[\\s\\S]*?\\*\\//g, '');\n        // Regex adjusted to be slightly more robust\n        const scopeHeadRegex = /@scope\\s*\\(([^)]+)\\)\\s*{/g;\n\n        let match;\n        const extractedRules = [];\n\n        while ((match = scopeHeadRegex.exec(cleanCss)) !== null) {\n            const scopeRootSelector = match[1].trim();\n            const bodyStart = match.index + match[0].length;\n            const bodyEnd = findClosingBrace(cleanCss, bodyStart - 1);\n\n            if (bodyEnd !== -1) {\n                const innerContent = cleanCss.substring(bodyStart, bodyEnd);\n                const transformedBlock = processBlock(innerContent, scopeRootSelector);\n                extractedRules.push(transformedBlock);\n            }\n        }\n        return extractedRules.length > 0 ? extractedRules.join('\\n') : null;\n    }\n\n    /**\n     * Process a block of CSS text\n     * @param {string} cssText\n     * @param {string} rootSelector\n     * @returns {string}\n     */\n    function processBlock(cssText, rootSelector) {\n        let result = '';\n        let cursor = 0;\n\n        while (cursor < cssText.length) {\n            const openBrace = cssText.indexOf('{', cursor);\n            if (openBrace === -1) break;\n\n            const headerRaw = cssText.substring(cursor, openBrace).trim();\n            const closeBrace = findClosingBrace(cssText, openBrace);\n            if (closeBrace === -1) break;\n\n            const blockBody = cssText.substring(openBrace + 1, closeBrace);\n\n            if (headerRaw.startsWith('@')) {\n                const isDefinitionRule = /^@(keyframes|font-face)/i.test(headerRaw);\n                if (isDefinitionRule) {\n                    result += `${headerRaw} {${blockBody}}\\n`;\n                } else {\n                    const processedBody = processBlock(blockBody, rootSelector);\n                    result += `${headerRaw} {\\n${processedBody}\\n}\\n`;\n                }\n            } else {\n                const newSelector = rewriteSelector(headerRaw, rootSelector);\n                if (newSelector) {\n                    result += `${newSelector} {${blockBody}}\\n`;\n                }\n            }\n            cursor = closeBrace + 1;\n        }\n        return result;\n    }\n\n    /**\n     * Rewrite a selector to use the root selector\n     * @param {string} selectorLine\n     * @param {string} rootSelector\n     * @returns {string}\n     */\n    function rewriteSelector(selectorLine, rootSelector) {\n        if (!selectorLine.trim()) return '';\n\n        const parts = splitByCommaBalanced(selectorLine);\n\n        return parts.map(part => {\n            const s = part.trim();\n\n            // 1. Explicit :scope pseudo-class\n            if (s.includes(':scope')) {\n                return s.replace(/:\\s*scope/g, rootSelector);\n            }\n\n            // 2. Nesting selector &\n            if (s.includes('&')) {\n                return s.replace(/&/g, rootSelector);\n            }\n\n            // 3. Implicit descendant (Standard Scoping)\n            return `${rootSelector} ${s}`;\n        }).join(', ');\n    }\n    /**\n     * Helper: Splits a CSS selector list by comma, ignoring commas inside parentheses.\n     * Handles: :is(.a, .b), :not(.a, .b), [attr=\"a,b\"]\n     * @param {string} text\n     * @returns {string[]}\n     */\n    function splitByCommaBalanced(text) {\n        const parts = [];\n        let buffer = '';\n        let depth = 0;\n        let inString = false;\n        let stringChar = '';\n\n        for (let i = 0; i < text.length; i++) {\n            const char = text[i];\n\n            // Handle Strings (to ignore commas inside quotes like [data-val=\"a,b\"])\n            if ((char === '\"' || char === \"'\") && text[i - 1] !== '\\\\') {\n                if (inString && char === stringChar) {\n                    inString = false;\n                } else if (!inString) {\n                    inString = true;\n                    stringChar = char;\n                }\n            }\n\n            // Handle Parentheses (only if not in string)\n            if (!inString) {\n                if (char === '(') depth++;\n                else if (char === ')') depth--;\n            }\n\n            // Split logic\n            if (char === ',' && depth === 0 && !inString) {\n                parts.push(buffer);\n                buffer = '';\n            } else {\n                buffer += char;\n            }\n        }\n\n        if (buffer) parts.push(buffer);\n        return parts;\n    }\n\n    /**\n     * Find the closing brace for a given open brace index\n     * @param {string} text\n     * @param {number} openBraceIndex\n     * @returns {number}\n     */\n    function findClosingBrace(text, openBraceIndex) {\n        let depth = 1;\n        for (let i = openBraceIndex + 1; i < text.length; i++) {\n            const char = text[i];\n            if (char === '{') depth++;\n            else if (char === '}') depth--;\n            if (depth === 0) return i;\n        }\n        return -1;\n    }\n\n    /**\n     * Inject styles into the document\n     * @param {string} cssText\n     * @param {string} source\n     */\n    function injectStyles(cssText, source) {\n        const blob = new Blob([cssText], { type: 'text/css' });\n        const url = URL.createObjectURL(blob);\n        const link = document.createElement('link');\n        link.rel = 'stylesheet';\n        link.href = url;\n        // Important: Mark this node so the observer ignores it!\n        link.setAttribute('data-polyfill-generated', 'true');\n        link.setAttribute('data-source', source);\n        document.head.appendChild(link);\n    }\n\n    // --- [Ignition] ---\n\n    // @ts-ignore 1. Scan currently existing nodes \n    document.querySelectorAll('link[rel=\"stylesheet\"], style').forEach(processNode);\n\n    // 2. Start watching for future nodes\n    observeMutations();\n}\n\nif (typeof window !== 'undefined') {\n    window.CSSScopePolyfill = CSSScopePolyfill;\n}\n\nexport default CSSScopePolyfill;\n"]}